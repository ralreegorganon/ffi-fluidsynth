# Generated by ffi_gen. Please do not change this file by hand.

require 'ffi'

module FluidSynth
  extend FFI::Library
  ffi_lib 'fluidsynth'
  
  FLUID_HINT_BOUNDED_BELOW = 0x1
  
  FLUID_HINT_BOUNDED_ABOVE = 0x2
  
  FLUID_HINT_TOGGLED = 0x4
  
  FLUID_HINT_SAMPLE_RATE = 0x8
  
  FLUID_HINT_LOGARITHMIC = 0x10
  
  FLUID_HINT_INTEGER = 0x20
  
  FLUID_HINT_FILENAME = 0x01
  
  FLUID_HINT_OPTIONLIST = 0x02
  
  FLUID_SYNTH_CHANNEL_INFO_NAME_SIZE = 32
  
  FLUID_REVERB_DEFAULT_ROOMSIZE = 0.2
  
  FLUID_REVERB_DEFAULT_DAMP = 0.0
  
  FLUID_REVERB_DEFAULT_WIDTH = 0.5
  
  FLUID_REVERB_DEFAULT_LEVEL = 0.9
  
  FLUID_CHORUS_DEFAULT_N = 3
  
  FLUID_CHORUS_DEFAULT_LEVEL = 2.0
  
  FLUID_CHORUS_DEFAULT_SPEED = 0.3
  
  FLUID_CHORUS_DEFAULT_DEPTH = 8.0
  
  FLUID_SAMPLETYPE_MONO = 1
  
  FLUID_SAMPLETYPE_RIGHT = 2
  
  FLUID_SAMPLETYPE_LEFT = 4
  
  FLUID_SAMPLETYPE_LINKED = 8
  
  FLUID_SAMPLETYPE_ROM = 0x8000
  
  FLUID_SEQ_WITH_TRACE = 0
  
  FLUID_NUM_MOD = 64
  
  FLUIDSYNTH_VERSION = "1.1.5"
  
  FLUIDSYNTH_VERSION_MAJOR = 1
  
  FLUIDSYNTH_VERSION_MINOR = 1
  
  FLUIDSYNTH_VERSION_MICRO = 5
  
  # (Not documented)
  class FluidHashtableT < FFI::Struct
  end
  
  # < Configuration settings instance
  class FluidSynthT < FFI::Struct
  end
  
  # < SoundFont channel info
  class FluidVoiceT < FFI::Struct
  end
  
  # < SoundFont modulator
  class FluidAudioDriverT < FFI::Struct
  end
  
  # < Audio driver instance
  class FluidFileRendererT < FFI::Struct
  end
  
  # < Audio file renderer instance
  class FluidPlayerT < FFI::Struct
  end
  
  # < MIDI player instance
  class FluidMidiEventT < FFI::Struct
  end
  
  # < MIDI event
  class FluidMidiDriverT < FFI::Struct
  end
  
  # < MIDI driver instance
  class FluidMidiRouterT < FFI::Struct
  end
  
  # < MIDI router instance
  class FluidMidiRouterRuleT < FFI::Struct
  end
  
  # < Command handler
  class FluidShellT < FFI::Struct
  end
  
  # < Command shell
  class FluidServerT < FFI::Struct
  end
  
  # < TCP/IP shell server instance
  class FluidEventT < FFI::Struct
  end
  
  # < Sequencer event
  class FluidSequencerT < FFI::Struct
  end
  
  # < Sequencer instance
  class FluidRamsfontT < FFI::Struct
  end
  
  # < RAM SoundFont
  class FluidRampresetT < FFI::Struct
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_types_enum).</em>
  # 
  # === Options:
  # :num_ ::
  #   < Undefined type
  # :int_ ::
  #   < Numeric (double)
  # :str_ ::
  #   < Integer
  # :set_ ::
  #   < String
  # 
  # @method _enum_fluid_types_enum_
  # @return [Symbol]
  # @scope class
  enum :fluid_types_enum, [
    :num_,
    :int_,
    :str_,
    :set_
  ]
  
  # (Not documented)
  # 
  # @method new_fluid_settings()
  # @return [FluidHashtableT] 
  # @scope class
  attach_function :new_fluid_settings, :new_fluid_settings, [], FluidHashtableT
  
  # (Not documented)
  # 
  # @method delete_fluid_settings(settings)
  # @param [FluidHashtableT] settings 
  # @return [nil] 
  # @scope class
  attach_function :delete_fluid_settings, :delete_fluid_settings, [FluidHashtableT], :void
  
  # (Not documented)
  # 
  # @method fluid_settings_get_type(settings, name)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_get_type, :fluid_settings_get_type, [FluidHashtableT, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_get_hints(settings, name)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_get_hints, :fluid_settings_get_hints, [FluidHashtableT, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_is_realtime(settings, name)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_is_realtime, :fluid_settings_is_realtime, [FluidHashtableT, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_setstr(settings, name, str)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [String] str 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_setstr, :fluid_settings_setstr, [FluidHashtableT, :string, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_copystr(settings, name, str, len)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [String] str 
  # @param [Integer] len 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_copystr, :fluid_settings_copystr, [FluidHashtableT, :string, :string, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_dupstr(settings, name, str)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [FFI::Pointer(**Char_S)] str 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_dupstr, :fluid_settings_dupstr, [FluidHashtableT, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_getstr(settings, name, str)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [FFI::Pointer(**Char_S)] str 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_getstr, :fluid_settings_getstr, [FluidHashtableT, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_getstr_default(settings, name)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @return [String] 
  # @scope class
  attach_function :fluid_settings_getstr_default, :fluid_settings_getstr_default, [FluidHashtableT, :string], :string
  
  # (Not documented)
  # 
  # @method fluid_settings_str_equal(settings, name, value)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [String] value 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_str_equal, :fluid_settings_str_equal, [FluidHashtableT, :string, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_setnum(settings, name, val)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [Float] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_setnum, :fluid_settings_setnum, [FluidHashtableT, :string, :double], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_getnum(settings, name, val)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [FFI::Pointer(*Double)] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_getnum, :fluid_settings_getnum, [FluidHashtableT, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_getnum_default(settings, name)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @return [Float] 
  # @scope class
  attach_function :fluid_settings_getnum_default, :fluid_settings_getnum_default, [FluidHashtableT, :string], :double
  
  # (Not documented)
  # 
  # @method fluid_settings_getnum_range(settings, name, min, max)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [FFI::Pointer(*Double)] min 
  # @param [FFI::Pointer(*Double)] max 
  # @return [nil] 
  # @scope class
  attach_function :fluid_settings_getnum_range, :fluid_settings_getnum_range, [FluidHashtableT, :string, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method fluid_settings_setint(settings, name, val)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_setint, :fluid_settings_setint, [FluidHashtableT, :string, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_getint(settings, name, val)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [FFI::Pointer(*Int)] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_getint, :fluid_settings_getint, [FluidHashtableT, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_getint_default(settings, name)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_getint_default, :fluid_settings_getint_default, [FluidHashtableT, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_getint_range(settings, name, min, max)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [FFI::Pointer(*Int)] min 
  # @param [FFI::Pointer(*Int)] max 
  # @return [nil] 
  # @scope class
  attach_function :fluid_settings_getint_range, :fluid_settings_getint_range, [FluidHashtableT, :string, :pointer, :pointer], :void
  
  # Callback function type used with fluid_settings_foreach_option()
  # @param data User defined data pointer
  # @param name Setting name
  # @param option A string option for this setting (iterates through the list)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_fluid_settings_foreach_option_t_(name, option)
  # @param [String] name 
  # @param [String] option 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  callback :fluid_settings_foreach_option_t, [:string, :string], :pointer
  
  # (Not documented)
  # 
  # @method fluid_settings_foreach_option(settings, name, data, func)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [FFI::Pointer(*Void)] data 
  # @param [Proc(_callback_fluid_settings_foreach_option_t_)] func 
  # @return [nil] 
  # @scope class
  attach_function :fluid_settings_foreach_option, :fluid_settings_foreach_option, [FluidHashtableT, :string, :pointer, :fluid_settings_foreach_option_t], :void
  
  # (Not documented)
  # 
  # @method fluid_settings_option_count(settings, name)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_settings_option_count, :fluid_settings_option_count, [FluidHashtableT, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_settings_option_concat(settings, name, separator)
  # @param [FluidHashtableT] settings 
  # @param [String] name 
  # @param [String] separator 
  # @return [String] 
  # @scope class
  attach_function :fluid_settings_option_concat, :fluid_settings_option_concat, [FluidHashtableT, :string, :string], :string
  
  # Callback function type used with fluid_settings_foreach()
  # @param data User defined data pointer
  # @param name Setting name
  # @param type Setting type (#fluid_types_enum)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_fluid_settings_foreach_t_(name, type)
  # @param [String] name 
  # @param [Integer] type 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  callback :fluid_settings_foreach_t, [:string, :int], :pointer
  
  # (Not documented)
  # 
  # @method fluid_settings_foreach(settings, data, func)
  # @param [FluidHashtableT] settings 
  # @param [FFI::Pointer(*Void)] data 
  # @param [Proc(_callback_fluid_settings_foreach_t_)] func 
  # @return [nil] 
  # @scope class
  attach_function :fluid_settings_foreach, :fluid_settings_foreach, [FluidHashtableT, :pointer, :fluid_settings_foreach_t], :void
  
  # < Synthesizer instance
  # 
  # = Fields:
  # :assigned ::
  #   (Integer) < TRUE if a preset is assigned, FALSE otherwise
  # :sfont_id ::
  #   (Integer) < ID of parent SoundFont
  # :bank ::
  #   (Integer) < MIDI bank number (0-16383)
  # :program ::
  #   (Integer) < MIDI program number (0-127)
  # :name ::
  #   (Array<Integer>) < Channel preset name
  # :reserved ::
  #   (Array<Integer>) < Reserved data for future expansion
  class FluidSynthChannelInfoT < FFI::Struct
    layout :assigned, :int,
           :sfont_id, :int,
           :bank, :int,
           :program, :int,
           :name, [:char, 32],
           :reserved, [:char, 32]
  end
  
  # (Not documented)
  # 
  # @method new_fluid_synth(settings)
  # @param [FluidHashtableT] settings 
  # @return [FluidSynthT] 
  # @scope class
  attach_function :new_fluid_synth, :new_fluid_synth, [FluidHashtableT], FluidSynthT
  
  # (Not documented)
  # 
  # @method delete_fluid_synth(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :delete_fluid_synth, :delete_fluid_synth, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_settings(synth)
  # @param [FluidSynthT] synth 
  # @return [FluidHashtableT] 
  # @scope class
  attach_function :fluid_synth_get_settings, :fluid_synth_get_settings, [FluidSynthT], FluidHashtableT
  
  # MIDI channel messages
  # 
  # @method fluid_synth_noteon(synth, chan, key, vel)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] key 
  # @param [Integer] vel 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_noteon, :fluid_synth_noteon, [FluidSynthT, :int, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_noteoff(synth, chan, key)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] key 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_noteoff, :fluid_synth_noteoff, [FluidSynthT, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_cc(synth, chan, ctrl, val)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] ctrl 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_cc, :fluid_synth_cc, [FluidSynthT, :int, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_cc(synth, chan, ctrl, pval)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] ctrl 
  # @param [FFI::Pointer(*Int)] pval 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_cc, :fluid_synth_get_cc, [FluidSynthT, :int, :int, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_sysex(synth, data, len, response, response_len, handled, dryrun)
  # @param [FluidSynthT] synth 
  # @param [String] data 
  # @param [Integer] len 
  # @param [String] response 
  # @param [FFI::Pointer(*Int)] response_len 
  # @param [FFI::Pointer(*Int)] handled 
  # @param [Integer] dryrun 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_sysex, :fluid_synth_sysex, [FluidSynthT, :string, :int, :string, :pointer, :pointer, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_pitch_bend(synth, chan, val)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_pitch_bend, :fluid_synth_pitch_bend, [FluidSynthT, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_pitch_bend(synth, chan, ppitch_bend)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [FFI::Pointer(*Int)] ppitch_bend 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_pitch_bend, :fluid_synth_get_pitch_bend, [FluidSynthT, :int, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_pitch_wheel_sens(synth, chan, val)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_pitch_wheel_sens, :fluid_synth_pitch_wheel_sens, [FluidSynthT, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_pitch_wheel_sens(synth, chan, pval)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [FFI::Pointer(*Int)] pval 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_pitch_wheel_sens, :fluid_synth_get_pitch_wheel_sens, [FluidSynthT, :int, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_program_change(synth, chan, program)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] program 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_program_change, :fluid_synth_program_change, [FluidSynthT, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_channel_pressure(synth, chan, val)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_channel_pressure, :fluid_synth_channel_pressure, [FluidSynthT, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_bank_select(synth, chan, bank)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] bank 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_bank_select, :fluid_synth_bank_select, [FluidSynthT, :int, :uint], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_sfont_select(synth, chan, sfont_id)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] sfont_id 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_sfont_select, :fluid_synth_sfont_select, [FluidSynthT, :int, :uint], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_program_select(synth, chan, sfont_id, bank_num, preset_num)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] sfont_id 
  # @param [Integer] bank_num 
  # @param [Integer] preset_num 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_program_select, :fluid_synth_program_select, [FluidSynthT, :int, :uint, :uint, :uint], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_program_select_by_sfont_name(synth, chan, sfont_name, bank_num, preset_num)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [String] sfont_name 
  # @param [Integer] bank_num 
  # @param [Integer] preset_num 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_program_select_by_sfont_name, :fluid_synth_program_select_by_sfont_name, [FluidSynthT, :int, :string, :uint, :uint], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_program(synth, chan, sfont_id, bank_num, preset_num)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [FFI::Pointer(*UInt)] sfont_id 
  # @param [FFI::Pointer(*UInt)] bank_num 
  # @param [FFI::Pointer(*UInt)] preset_num 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_program, :fluid_synth_get_program, [FluidSynthT, :int, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_unset_program(synth, chan)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_unset_program, :fluid_synth_unset_program, [FluidSynthT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_channel_info(synth, chan, info)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [FluidSynthChannelInfoT] info 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_channel_info, :fluid_synth_get_channel_info, [FluidSynthT, :int, FluidSynthChannelInfoT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_program_reset(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_program_reset, :fluid_synth_program_reset, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_system_reset(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_system_reset, :fluid_synth_system_reset, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_all_notes_off(synth, chan)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_all_notes_off, :fluid_synth_all_notes_off, [FluidSynthT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_all_sounds_off(synth, chan)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_all_sounds_off, :fluid_synth_all_sounds_off, [FluidSynthT, :int], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_midi_channel_type).</em>
  # 
  # === Options:
  # :melodic ::
  #   
  # :drum ::
  #   
  # 
  # @method _enum_fluid_midi_channel_type_
  # @return [Symbol]
  # @scope class
  enum :fluid_midi_channel_type, [
    :melodic, 0,
    :drum, 1
  ]
  
  # (Not documented)
  # 
  # @method fluid_synth_set_channel_type(synth, chan, type)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_set_channel_type, :fluid_synth_set_channel_type, [FluidSynthT, :int, :int], :int
  
  # Low level access
  # 
  # @method fluid_synth_get_channel_preset(synth, chan)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @return [FFI::Pointer(*FluidPresetT)] 
  # @scope class
  attach_function :fluid_synth_get_channel_preset, :fluid_synth_get_channel_preset, [FluidSynthT, :int], :pointer
  
  # (Not documented)
  # 
  # @method fluid_synth_start(synth, id, preset, audio_chan, midi_chan, key, vel)
  # @param [FluidSynthT] synth 
  # @param [Integer] id 
  # @param [FFI::Pointer(*FluidPresetT)] preset 
  # @param [Integer] audio_chan 
  # @param [Integer] midi_chan 
  # @param [Integer] key 
  # @param [Integer] vel 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_start, :fluid_synth_start, [FluidSynthT, :uint, :pointer, :int, :int, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_stop(synth, id)
  # @param [FluidSynthT] synth 
  # @param [Integer] id 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_stop, :fluid_synth_stop, [FluidSynthT, :uint], :int
  
  # SoundFont management
  # 
  # @method fluid_synth_sfload(synth, filename, reset_presets)
  # @param [FluidSynthT] synth 
  # @param [String] filename 
  # @param [Integer] reset_presets 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_sfload, :fluid_synth_sfload, [FluidSynthT, :string, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_sfreload(synth, id)
  # @param [FluidSynthT] synth 
  # @param [Integer] id 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_sfreload, :fluid_synth_sfreload, [FluidSynthT, :uint], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_sfunload(synth, id, reset_presets)
  # @param [FluidSynthT] synth 
  # @param [Integer] id 
  # @param [Integer] reset_presets 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_sfunload, :fluid_synth_sfunload, [FluidSynthT, :uint, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_add_sfont(synth, sfont)
  # @param [FluidSynthT] synth 
  # @param [FFI::Pointer(*FluidSfontT)] sfont 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_add_sfont, :fluid_synth_add_sfont, [FluidSynthT, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_remove_sfont(synth, sfont)
  # @param [FluidSynthT] synth 
  # @param [FFI::Pointer(*FluidSfontT)] sfont 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_remove_sfont, :fluid_synth_remove_sfont, [FluidSynthT, :pointer], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_sfcount(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_sfcount, :fluid_synth_sfcount, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_sfont(synth, num)
  # @param [FluidSynthT] synth 
  # @param [Integer] num 
  # @return [FFI::Pointer(*FluidSfontT)] 
  # @scope class
  attach_function :fluid_synth_get_sfont, :fluid_synth_get_sfont, [FluidSynthT, :uint], :pointer
  
  # (Not documented)
  # 
  # @method fluid_synth_get_sfont_by_id(synth, id)
  # @param [FluidSynthT] synth 
  # @param [Integer] id 
  # @return [FFI::Pointer(*FluidSfontT)] 
  # @scope class
  attach_function :fluid_synth_get_sfont_by_id, :fluid_synth_get_sfont_by_id, [FluidSynthT, :uint], :pointer
  
  # (Not documented)
  # 
  # @method fluid_synth_get_sfont_by_name(synth, name)
  # @param [FluidSynthT] synth 
  # @param [String] name 
  # @return [FFI::Pointer(*FluidSfontT)] 
  # @scope class
  attach_function :fluid_synth_get_sfont_by_name, :fluid_synth_get_sfont_by_name, [FluidSynthT, :string], :pointer
  
  # (Not documented)
  # 
  # @method fluid_synth_set_bank_offset(synth, sfont_id, offset)
  # @param [FluidSynthT] synth 
  # @param [Integer] sfont_id 
  # @param [Integer] offset 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_set_bank_offset, :fluid_synth_set_bank_offset, [FluidSynthT, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_bank_offset(synth, sfont_id)
  # @param [FluidSynthT] synth 
  # @param [Integer] sfont_id 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_bank_offset, :fluid_synth_get_bank_offset, [FluidSynthT, :int], :int
  
  # Reverb 
  # 
  # @method fluid_synth_set_reverb(synth, roomsize, damping, width, level)
  # @param [FluidSynthT] synth 
  # @param [Float] roomsize 
  # @param [Float] damping 
  # @param [Float] width 
  # @param [Float] level 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_set_reverb, :fluid_synth_set_reverb, [FluidSynthT, :double, :double, :double, :double], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_set_reverb_on(synth, on)
  # @param [FluidSynthT] synth 
  # @param [Integer] on 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_set_reverb_on, :fluid_synth_set_reverb_on, [FluidSynthT, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_get_reverb_roomsize(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_reverb_roomsize, :fluid_synth_get_reverb_roomsize, [FluidSynthT], :double
  
  # (Not documented)
  # 
  # @method fluid_synth_get_reverb_damp(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_reverb_damp, :fluid_synth_get_reverb_damp, [FluidSynthT], :double
  
  # (Not documented)
  # 
  # @method fluid_synth_get_reverb_level(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_reverb_level, :fluid_synth_get_reverb_level, [FluidSynthT], :double
  
  # (Not documented)
  # 
  # @method fluid_synth_get_reverb_width(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_reverb_width, :fluid_synth_get_reverb_width, [FluidSynthT], :double
  
  # Chorus modulation waveform type.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_chorus_mod).</em>
  # 
  # === Options:
  # :sine ::
  #   
  # :triangle ::
  #   < Sine wave chorus modulation
  # 
  # @method _enum_fluid_chorus_mod_
  # @return [Symbol]
  # @scope class
  enum :fluid_chorus_mod, [
    :sine, 0,
    :triangle, 1
  ]
  
  # < Triangle wave chorus modulation
  # 
  # @method fluid_synth_set_chorus(synth, nr, level, speed, depth_ms, type)
  # @param [FluidSynthT] synth 
  # @param [Integer] nr 
  # @param [Float] level 
  # @param [Float] speed 
  # @param [Float] depth_ms 
  # @param [Integer] type 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_set_chorus, :fluid_synth_set_chorus, [FluidSynthT, :int, :double, :double, :double, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_set_chorus_on(synth, on)
  # @param [FluidSynthT] synth 
  # @param [Integer] on 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_set_chorus_on, :fluid_synth_set_chorus_on, [FluidSynthT, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_get_chorus_nr(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_chorus_nr, :fluid_synth_get_chorus_nr, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_chorus_level(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_chorus_level, :fluid_synth_get_chorus_level, [FluidSynthT], :double
  
  # (Not documented)
  # 
  # @method fluid_synth_get_chorus_speed_hz(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_chorus_speed_hz, :fluid_synth_get_chorus_speed_Hz, [FluidSynthT], :double
  
  # (Not documented)
  # 
  # @method fluid_synth_get_chorus_depth_ms(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_chorus_depth_ms, :fluid_synth_get_chorus_depth_ms, [FluidSynthT], :double
  
  # (Not documented)
  # 
  # @method fluid_synth_get_chorus_type(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_chorus_type, :fluid_synth_get_chorus_type, [FluidSynthT], :int
  
  # Audio and MIDI channels
  # 
  # @method fluid_synth_count_midi_channels(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_count_midi_channels, :fluid_synth_count_midi_channels, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_count_audio_channels(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_count_audio_channels, :fluid_synth_count_audio_channels, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_count_audio_groups(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_count_audio_groups, :fluid_synth_count_audio_groups, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_count_effects_channels(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_count_effects_channels, :fluid_synth_count_effects_channels, [FluidSynthT], :int
  
  # Synthesis parameters
  # 
  # @method fluid_synth_set_sample_rate(synth, sample_rate)
  # @param [FluidSynthT] synth 
  # @param [Float] sample_rate 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_set_sample_rate, :fluid_synth_set_sample_rate, [FluidSynthT, :float], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_set_gain(synth, gain)
  # @param [FluidSynthT] synth 
  # @param [Float] gain 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_set_gain, :fluid_synth_set_gain, [FluidSynthT, :float], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_get_gain(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_gain, :fluid_synth_get_gain, [FluidSynthT], :float
  
  # (Not documented)
  # 
  # @method fluid_synth_set_polyphony(synth, polyphony)
  # @param [FluidSynthT] synth 
  # @param [Integer] polyphony 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_set_polyphony, :fluid_synth_set_polyphony, [FluidSynthT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_polyphony(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_polyphony, :fluid_synth_get_polyphony, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_active_voice_count(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_active_voice_count, :fluid_synth_get_active_voice_count, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_internal_bufsize(synth)
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_get_internal_bufsize, :fluid_synth_get_internal_bufsize, [FluidSynthT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_set_interp_method(synth, chan, interp_method)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] interp_method 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_set_interp_method, :fluid_synth_set_interp_method, [FluidSynthT, :int, :int], :int
  
  # Synthesis interpolation method.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_interp).</em>
  # 
  # === Options:
  # :none ::
  #   
  # :linear ::
  #   < No interpolation: Fastest, but questionable audio quality
  # :_4thorder ::
  #   < Straight-line interpolation: A bit slower, reasonable audio quality
  # :_7thorder ::
  #   < Fourth-order interpolation, good quality, the default
  # 
  # @method _enum_fluid_interp_
  # @return [Symbol]
  # @scope class
  enum :fluid_interp, [
    :none, 0,
    :linear, 1,
    :_4thorder, 4,
    :_7thorder, 7
  ]
  
  # Generator interface
  # 
  # @method fluid_synth_set_gen(synth, chan, param, value)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] param 
  # @param [Float] value 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_set_gen, :fluid_synth_set_gen, [FluidSynthT, :int, :int, :float], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_set_gen2(synth, chan, param, value, absolute, normalized)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] param 
  # @param [Float] value 
  # @param [Integer] absolute 
  # @param [Integer] normalized 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_set_gen2, :fluid_synth_set_gen2, [FluidSynthT, :int, :int, :float, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_get_gen(synth, chan, param)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] param 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_gen, :fluid_synth_get_gen, [FluidSynthT, :int, :int], :float
  
  # Tuning
  # 
  # @method fluid_synth_create_key_tuning(synth, bank, prog, name, pitch)
  # @param [FluidSynthT] synth 
  # @param [Integer] bank 
  # @param [Integer] prog 
  # @param [String] name 
  # @param [FFI::Pointer(*Double)] pitch 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_create_key_tuning, :fluid_synth_create_key_tuning, [FluidSynthT, :int, :int, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_activate_key_tuning(synth, bank, prog, name, pitch, apply)
  # @param [FluidSynthT] synth 
  # @param [Integer] bank 
  # @param [Integer] prog 
  # @param [String] name 
  # @param [FFI::Pointer(*Double)] pitch 
  # @param [Integer] apply 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_activate_key_tuning, :fluid_synth_activate_key_tuning, [FluidSynthT, :int, :int, :string, :pointer, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_create_octave_tuning(synth, bank, prog, name, pitch)
  # @param [FluidSynthT] synth 
  # @param [Integer] bank 
  # @param [Integer] prog 
  # @param [String] name 
  # @param [FFI::Pointer(*Double)] pitch 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_create_octave_tuning, :fluid_synth_create_octave_tuning, [FluidSynthT, :int, :int, :string, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_activate_octave_tuning(synth, bank, prog, name, pitch, apply)
  # @param [FluidSynthT] synth 
  # @param [Integer] bank 
  # @param [Integer] prog 
  # @param [String] name 
  # @param [FFI::Pointer(*Double)] pitch 
  # @param [Integer] apply 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_activate_octave_tuning, :fluid_synth_activate_octave_tuning, [FluidSynthT, :int, :int, :string, :pointer, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_tune_notes(synth, bank, prog, len, keys, pitch, apply)
  # @param [FluidSynthT] synth 
  # @param [Integer] bank 
  # @param [Integer] prog 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Int)] keys 
  # @param [FFI::Pointer(*Double)] pitch 
  # @param [Integer] apply 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_tune_notes, :fluid_synth_tune_notes, [FluidSynthT, :int, :int, :int, :pointer, :pointer, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_select_tuning(synth, chan, bank, prog)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] bank 
  # @param [Integer] prog 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_select_tuning, :fluid_synth_select_tuning, [FluidSynthT, :int, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_activate_tuning(synth, chan, bank, prog, apply)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] bank 
  # @param [Integer] prog 
  # @param [Integer] apply 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_activate_tuning, :fluid_synth_activate_tuning, [FluidSynthT, :int, :int, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_reset_tuning(synth, chan)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_reset_tuning, :fluid_synth_reset_tuning, [FluidSynthT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_deactivate_tuning(synth, chan, apply)
  # @param [FluidSynthT] synth 
  # @param [Integer] chan 
  # @param [Integer] apply 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_deactivate_tuning, :fluid_synth_deactivate_tuning, [FluidSynthT, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_tuning_iteration_start(synth)
  # @param [FluidSynthT] synth 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_tuning_iteration_start, :fluid_synth_tuning_iteration_start, [FluidSynthT], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_tuning_iteration_next(synth, bank, prog)
  # @param [FluidSynthT] synth 
  # @param [FFI::Pointer(*Int)] bank 
  # @param [FFI::Pointer(*Int)] prog 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_tuning_iteration_next, :fluid_synth_tuning_iteration_next, [FluidSynthT, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_tuning_dump(synth, bank, prog, name, len, pitch)
  # @param [FluidSynthT] synth 
  # @param [Integer] bank 
  # @param [Integer] prog 
  # @param [String] name 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Double)] pitch 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_tuning_dump, :fluid_synth_tuning_dump, [FluidSynthT, :int, :int, :string, :int, :pointer], :int
  
  # Misc
  # 
  # @method fluid_synth_get_cpu_load(synth)
  # @param [FluidSynthT] synth 
  # @return [Float] 
  # @scope class
  attach_function :fluid_synth_get_cpu_load, :fluid_synth_get_cpu_load, [FluidSynthT], :double
  
  # (Not documented)
  # 
  # @method fluid_synth_error(synth)
  # @param [FluidSynthT] synth 
  # @return [String] 
  # @scope class
  attach_function :fluid_synth_error, :fluid_synth_error, [FluidSynthT], :string
  
  # Synthesizer plugin
  # 
  # To create a synthesizer plugin, create the synthesizer as
  # explained above. Once the synthesizer is created you can call
  # any of the functions below to get the audio. 
  # 
  # @method fluid_synth_write_s16(synth, len, lout, loff, lincr, rout, roff, rincr)
  # @param [FluidSynthT] synth 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Void)] lout 
  # @param [Integer] loff 
  # @param [Integer] lincr 
  # @param [FFI::Pointer(*Void)] rout 
  # @param [Integer] roff 
  # @param [Integer] rincr 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_write_s16, :fluid_synth_write_s16, [FluidSynthT, :int, :pointer, :int, :int, :pointer, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_write_float(synth, len, lout, loff, lincr, rout, roff, rincr)
  # @param [FluidSynthT] synth 
  # @param [Integer] len 
  # @param [FFI::Pointer(*Void)] lout 
  # @param [Integer] loff 
  # @param [Integer] lincr 
  # @param [FFI::Pointer(*Void)] rout 
  # @param [Integer] roff 
  # @param [Integer] rincr 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_write_float, :fluid_synth_write_float, [FluidSynthT, :int, :pointer, :int, :int, :pointer, :int, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_nwrite_float(synth, len, left, right, fx_left, fx_right)
  # @param [FluidSynthT] synth 
  # @param [Integer] len 
  # @param [FFI::Pointer(**Float)] left 
  # @param [FFI::Pointer(**Float)] right 
  # @param [FFI::Pointer(**Float)] fx_left 
  # @param [FFI::Pointer(**Float)] fx_right 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_nwrite_float, :fluid_synth_nwrite_float, [FluidSynthT, :int, :pointer, :pointer, :pointer, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_process(synth, len, nin, in, nout, out)
  # @param [FluidSynthT] synth 
  # @param [Integer] len 
  # @param [Integer] nin 
  # @param [FFI::Pointer(**Float)] in 
  # @param [Integer] nout 
  # @param [FFI::Pointer(**Float)] out 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_process, :fluid_synth_process, [FluidSynthT, :int, :int, :pointer, :int, :pointer], :int
  
  # Type definition of the synthesizer's audio callback function.
  # @param synth FluidSynth instance
  # @param len Count of audio frames to synthesize
  # @param out1 Array to store left channel of audio to
  # @param loff Offset index in 'out1' for first sample
  # @param lincr Increment between samples stored to 'out1'
  # @param out2 Array to store right channel of audio to
  # @param roff Offset index in 'out2' for first sample
  # @param rincr Increment between samples stored to 'out2'
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_fluid_audio_callback_t_(len, out1, loff, lincr, out2, roff, rincr)
  # @param [Integer] len 
  # @param [FFI::Pointer(*Void)] out1 
  # @param [Integer] loff 
  # @param [Integer] lincr 
  # @param [FFI::Pointer(*Void)] out2 
  # @param [Integer] roff 
  # @param [Integer] rincr 
  # @return [FluidSynthT] 
  # @scope class
  callback :fluid_audio_callback_t, [:int, :pointer, :int, :int, :pointer, :int, :int], FluidSynthT
  
  # Synthesizer's interface to handle SoundFont loaders
  # 
  # @method fluid_synth_add_sfloader(synth, loader)
  # @param [FluidSynthT] synth 
  # @param [FFI::Pointer(*FluidSfloaderT)] loader 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_add_sfloader, :fluid_synth_add_sfloader, [FluidSynthT, :pointer], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_alloc_voice(synth, sample, channum, key, vel)
  # @param [FluidSynthT] synth 
  # @param [FFI::Pointer(*FluidSampleT)] sample 
  # @param [Integer] channum 
  # @param [Integer] key 
  # @param [Integer] vel 
  # @return [FluidVoiceT] 
  # @scope class
  attach_function :fluid_synth_alloc_voice, :fluid_synth_alloc_voice, [FluidSynthT, :pointer, :int, :int, :int], FluidVoiceT
  
  # (Not documented)
  # 
  # @method fluid_synth_start_voice(synth, voice)
  # @param [FluidSynthT] synth 
  # @param [FluidVoiceT] voice 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_start_voice, :fluid_synth_start_voice, [FluidSynthT, FluidVoiceT], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_get_voicelist(synth, buf, bufsize, id)
  # @param [FluidSynthT] synth 
  # @param [FFI::Pointer(**FluidVoiceT)] buf 
  # @param [Integer] bufsize 
  # @param [Integer] id 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_get_voicelist, :fluid_synth_get_voicelist, [FluidSynthT, :pointer, :int, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_synth_handle_midi_event(data, event)
  # @param [FFI::Pointer(*Void)] data 
  # @param [FluidMidiEventT] event 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_synth_handle_midi_event, :fluid_synth_handle_midi_event, [:pointer, FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_synth_set_midi_router(synth, router)
  # @param [FluidSynthT] synth 
  # @param [FluidMidiRouterT] router 
  # @return [nil] 
  # @scope class
  attach_function :fluid_synth_set_midi_router, :fluid_synth_set_midi_router, [FluidSynthT, FluidMidiRouterT], :void
  
  # < Synthesis voice instance
  # 
  # = Fields:
  # :data ::
  #   (FFI::Pointer(*Void)) < User defined data pointer
  # :free ::
  #   (FFI::Pointer(*)) The free method should free the memory allocated for the loader in
  #   addition to any private data.
  #   @param loader SoundFont loader
  #   @return Should return 0 if no error occured, non-zero otherwise
  # :load ::
  #   (FFI::Pointer(*)) Method to load an instrument file (does not actually need to be a real file name,
  #   could be another type of string identifier that the \a loader understands).
  #   @param loader SoundFont loader
  #   @param filename File name or other string identifier
  #   @return The loaded instrument file (SoundFont) or NULL if an error occured.
  class FluidSfloaderT < FFI::Struct
    layout :data, :pointer,
           :free, :pointer,
           :load, :pointer
  end
  
  # < SoundFont loader plugin
  # 
  # = Fields:
  # :data ::
  #   (FFI::Pointer(*Void)) < User defined data
  # :id ::
  #   (Integer) < SoundFont ID
  # :free ::
  #   (FFI::Pointer(*)) Method to free a virtual SoundFont bank.
  #   @param sfont Virtual SoundFont to free.
  #   @return Should return 0 when it was able to free all resources or non-zero
  #     if some of the samples could not be freed because they are still in use,
  #     in which case the free will be tried again later, until success.
  # :get_name ::
  #   (FFI::Pointer(*)) Method to return the name of a virtual SoundFont.
  #   @param sfont Virtual SoundFont
  #   @return The name of the virtual SoundFont.
  # :get_preset ::
  #   (FFI::Pointer(*)) Get a virtual SoundFont preset by bank and program numbers.
  #   @param sfont Virtual SoundFont
  #   @param bank MIDI bank number (0-16384)
  #   @param prenum MIDI preset number (0-127)
  #   @return Should return an allocated virtual preset or NULL if it could not
  #     be found.
  # :iteration_start ::
  #   (FFI::Pointer(*)) Start virtual SoundFont preset iteration method.
  #   @param sfont Virtual SoundFont
  #   
  #   Starts/re-starts virtual preset iteration in a SoundFont.
  # :iteration_next ::
  #   (FFI::Pointer(*)) Virtual SoundFont preset iteration function.
  #   @param sfont Virtual SoundFont
  #   @param preset Caller supplied preset to fill in with current preset information
  #   @return 0 when no more presets are available, 1 otherwise
  #   
  #   Should store preset information to the caller supplied \a preset structure
  #   and advance the internal iteration state to the next preset for subsequent
  #   calls.
  class FluidSfontT < FFI::Struct
    layout :data, :pointer,
           :id, :uint,
           :free, :pointer,
           :get_name, :pointer,
           :get_preset, :pointer,
           :iteration_start, :pointer,
           :iteration_next, :pointer
  end
  
  # < SoundFont
  # 
  # = Fields:
  # :data ::
  #   (FFI::Pointer(*Void)) < User supplied data
  # :sfont ::
  #   (FluidSfontT) < Parent virtual SoundFont
  # :free ::
  #   (FFI::Pointer(*)) Method to free a virtual SoundFont preset.
  #   @param preset Virtual SoundFont preset
  #   @return Should return 0
  # :get_name ::
  #   (FFI::Pointer(*)) Method to get a virtual SoundFont preset name.
  #   @param preset Virtual SoundFont preset
  #   @return Should return the name of the preset.  The returned string must be
  #     valid for the duration of the virtual preset (or the duration of the
  #     SoundFont, in the case of preset iteration).
  # :get_banknum ::
  #   (FFI::Pointer(*)) Method to get a virtual SoundFont preset MIDI bank number.
  #   @param preset Virtual SoundFont preset
  #   @param return The bank number of the preset
  # :get_num ::
  #   (FFI::Pointer(*)) Method to get a virtual SoundFont preset MIDI program number.
  #   @param preset Virtual SoundFont preset
  #   @param return The program number of the preset
  # :noteon ::
  #   (FFI::Pointer(*)) Method to handle a noteon event (synthesize the instrument).
  #   @param preset Virtual SoundFont preset
  #   @param synth Synthesizer instance
  #   @param chan MIDI channel number of the note on event
  #   @param key MIDI note number (0-127)
  #   @param vel MIDI velocity (0-127)
  #   @return #FLUID_OK on success (0) or #FLUID_FAILED (-1) otherwise
  #   
  #   This method may be called from within synthesis context and therefore
  #   should be as efficient as possible and not perform any operations considered
  #   bad for realtime audio output (memory allocations and other OS calls).
  #   
  #   Call fluid_synth_alloc_voice() for every sample that has
  #   to be played. fluid_synth_alloc_voice() expects a pointer to a
  #   #fluid_sample_t structure and returns a pointer to the opaque
  #   #fluid_voice_t structure. To set or increment the values of a
  #   generator, use fluid_voice_gen_set() or fluid_voice_gen_incr(). When you are
  #   finished initializing the voice call fluid_voice_start() to
  #   start playing the synthesis voice.  Starting with FluidSynth 1.1.0 all voices
  #   created will be started at the same time.
  # :notify ::
  #   (FFI::Pointer(*)) Virtual SoundFont preset notify method.
  #   @param preset Virtual SoundFont preset
  #   @param reason #FLUID_PRESET_SELECTED or #FLUID_PRESET_UNSELECTED
  #   @param chan MIDI channel number
  #   @return Should return #FLUID_OK
  #   
  #   Implement this optional method if the preset needs to be notified about
  #   preset select and unselect events.
  #   
  #   This method may be called from within synthesis context and therefore
  #   should be as efficient as possible and not perform any operations considered
  #   bad for realtime audio output (memory allocations and other OS calls).
  class FluidPresetT < FFI::Struct
    layout :data, :pointer,
           :sfont, FluidSfontT,
           :free, :pointer,
           :get_name, :pointer,
           :get_banknum, :pointer,
           :get_num, :pointer,
           :noteon, :pointer,
           :notify, :pointer
  end
  
  # < SoundFont preset
  # 
  # = Fields:
  # :name ::
  #   (Array<Integer>) < Sample name
  # :start ::
  #   (Integer) < Start index
  # :end ::
  #   (Integer) < End index, index of last valid sample point (contrary to SF spec)
  # :loopstart ::
  #   (Integer) < Loop start index
  # :loopend ::
  #   (Integer) < Loop end index, first point following the loop (superimposed on loopstart)
  # :samplerate ::
  #   (Integer) < Sample rate
  # :origpitch ::
  #   (Integer) < Original pitch (MIDI note number, 0-127)
  # :pitchadj ::
  #   (Integer) < Fine pitch adjustment (+/- 99 cents)
  # :sampletype ::
  #   (Integer) < Values: #FLUID_SAMPLETYPE_MONO, FLUID_SAMPLETYPE_RIGHT, FLUID_SAMPLETYPE_LEFT, FLUID_SAMPLETYPE_ROM
  # :valid ::
  #   (Integer) < Should be TRUE if sample data is valid, FALSE otherwise (in which case it will not be synthesized)
  # :data ::
  #   (FFI::Pointer(*Short)) < Pointer to the sample's data
  # :amplitude_that_reaches_noise_floor_is_valid ::
  #   (Integer) < Indicates if \a amplitude_that_reaches_noise_floor is valid (TRUE), set to FALSE initially to calculate.
  # :amplitude_that_reaches_noise_floor ::
  #   (Float) < The amplitude at which the sample's loop will be below the noise floor.  For voice off optimization, calculated automatically.
  # :refcount ::
  #   (Integer) < Count of voices using this sample (use #fluid_sample_refcount to access this field)
  # :notify ::
  #   (FFI::Pointer(*)) Implement this function to receive notification when sample is no longer used.
  #   @param sample Virtual SoundFont sample
  #   @param reason #FLUID_SAMPLE_DONE only currently
  #   @return Should return #FLUID_OK
  # :userdata ::
  #   (FFI::Pointer(*Void)) < User defined data
  class FluidSampleT < FFI::Struct
    layout :name, [:char, 21],
           :start, :uint,
           :end, :uint,
           :loopstart, :uint,
           :loopend, :uint,
           :samplerate, :uint,
           :origpitch, :int,
           :pitchadj, :int,
           :sampletype, :int,
           :valid, :int,
           :data, :pointer,
           :amplitude_that_reaches_noise_floor_is_valid, :int,
           :amplitude_that_reaches_noise_floor, :double,
           :refcount, :uint,
           :notify, :pointer,
           :userdata, :pointer
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_fluid_audio_func_t_(len, nin, in, nout, out)
  # @param [Integer] len 
  # @param [Integer] nin 
  # @param [FFI::Pointer(**Float)] in 
  # @param [Integer] nout 
  # @param [FFI::Pointer(**Float)] out 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  callback :fluid_audio_func_t, [:int, :int, :pointer, :int, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method new_fluid_audio_driver(settings, synth)
  # @param [FluidHashtableT] settings 
  # @param [FluidSynthT] synth 
  # @return [FluidAudioDriverT] 
  # @scope class
  attach_function :new_fluid_audio_driver, :new_fluid_audio_driver, [FluidHashtableT, FluidSynthT], FluidAudioDriverT
  
  # (Not documented)
  # 
  # @method new_fluid_audio_driver2(settings, func, data)
  # @param [FluidHashtableT] settings 
  # @param [Proc(_callback_fluid_audio_func_t_)] func 
  # @param [FFI::Pointer(*Void)] data 
  # @return [FluidAudioDriverT] 
  # @scope class
  attach_function :new_fluid_audio_driver2, :new_fluid_audio_driver2, [FluidHashtableT, :fluid_audio_func_t, :pointer], FluidAudioDriverT
  
  # (Not documented)
  # 
  # @method delete_fluid_audio_driver(driver)
  # @param [FluidAudioDriverT] driver 
  # @return [nil] 
  # @scope class
  attach_function :delete_fluid_audio_driver, :delete_fluid_audio_driver, [FluidAudioDriverT], :void
  
  # (Not documented)
  # 
  # @method new_fluid_file_renderer(synth)
  # @param [FluidSynthT] synth 
  # @return [FluidFileRendererT] 
  # @scope class
  attach_function :new_fluid_file_renderer, :new_fluid_file_renderer, [FluidSynthT], FluidFileRendererT
  
  # (Not documented)
  # 
  # @method fluid_file_renderer_process_block(dev)
  # @param [FluidFileRendererT] dev 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_file_renderer_process_block, :fluid_file_renderer_process_block, [FluidFileRendererT], :int
  
  # (Not documented)
  # 
  # @method delete_fluid_file_renderer(dev)
  # @param [FluidFileRendererT] dev 
  # @return [nil] 
  # @scope class
  attach_function :delete_fluid_file_renderer, :delete_fluid_file_renderer, [FluidFileRendererT], :void
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_seq_event_type).</em>
  # 
  # === Options:
  # :note ::
  #   
  # :noteon ::
  #   < Note event with duration
  # :noteoff ::
  #   < Note on event
  # :allsoundsoff ::
  #   < Note off event
  # :allnotesoff ::
  #   < All sounds off event
  # :bankselect ::
  #   < All notes off event
  # :programchange ::
  #   < Bank select message
  # :programselect ::
  #   < Program change message
  # :pitchbend ::
  #   < Program select message (DOCME)
  # :pitchwheelsens ::
  #   < Pitch bend message
  # :modulation ::
  #   < Pitch wheel sensitivity set message @since 1.1.0 was mispelled previously
  # :sustain ::
  #   < Modulation controller event
  # :controlchange ::
  #   < Sustain controller event
  # :pan ::
  #   < MIDI control change event
  # :volume ::
  #   < Stereo pan set event
  # :reverbsend ::
  #   < Volume set event
  # :chorussend ::
  #   < Reverb send set event
  # :timer ::
  #   < Chorus send set event
  # :anycontrolchange ::
  #   < Timer event (DOCME)
  # :channelpressure ::
  #   < DOCME (used for remove_events only)
  # :systemreset ::
  #   < Channel aftertouch event @since 1.1.0
  # :unregistering ::
  #   < System reset event @since 1.1.0
  # :lastevent ::
  #   < Called when a sequencer client is being unregistered. @since 1.1.0
  # 
  # @method _enum_fluid_seq_event_type_
  # @return [Symbol]
  # @scope class
  enum :fluid_seq_event_type, [
    :note, 0,
    :noteon,
    :noteoff,
    :allsoundsoff,
    :allnotesoff,
    :bankselect,
    :programchange,
    :programselect,
    :pitchbend,
    :pitchwheelsens,
    :modulation,
    :sustain,
    :controlchange,
    :pan,
    :volume,
    :reverbsend,
    :chorussend,
    :timer,
    :anycontrolchange,
    :channelpressure,
    :systemreset,
    :unregistering,
    :lastevent
  ]
  
  # (Not documented)
  # 
  # @method new_fluid_event()
  # @return [FluidEventT] 
  # @scope class
  attach_function :new_fluid_event, :new_fluid_event, [], FluidEventT
  
  # (Not documented)
  # 
  # @method delete_fluid_event(evt)
  # @param [FluidEventT] evt 
  # @return [nil] 
  # @scope class
  attach_function :delete_fluid_event, :delete_fluid_event, [FluidEventT], :void
  
  # Initializing events
  # 
  # @method fluid_event_set_source(evt, src)
  # @param [FluidEventT] evt 
  # @param [Integer] src 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_set_source, :fluid_event_set_source, [FluidEventT, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_set_dest(evt, dest)
  # @param [FluidEventT] evt 
  # @param [Integer] dest 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_set_dest, :fluid_event_set_dest, [FluidEventT, :short], :void
  
  # Timer events
  # 
  # @method fluid_event_timer(evt, data)
  # @param [FluidEventT] evt 
  # @param [FFI::Pointer(*Void)] data 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_timer, :fluid_event_timer, [FluidEventT, :pointer], :void
  
  # Note events
  # 
  # @method fluid_event_note(evt, channel, key, vel, duration)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] key 
  # @param [Integer] vel 
  # @param [Integer] duration 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_note, :fluid_event_note, [FluidEventT, :int, :short, :short, :uint], :void
  
  # (Not documented)
  # 
  # @method fluid_event_noteon(evt, channel, key, vel)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] key 
  # @param [Integer] vel 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_noteon, :fluid_event_noteon, [FluidEventT, :int, :short, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_noteoff(evt, channel, key)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] key 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_noteoff, :fluid_event_noteoff, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_all_sounds_off(evt, channel)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_all_sounds_off, :fluid_event_all_sounds_off, [FluidEventT, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_event_all_notes_off(evt, channel)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_all_notes_off, :fluid_event_all_notes_off, [FluidEventT, :int], :void
  
  # Instrument selection
  # 
  # @method fluid_event_bank_select(evt, channel, bank_num)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] bank_num 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_bank_select, :fluid_event_bank_select, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_program_change(evt, channel, preset_num)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] preset_num 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_program_change, :fluid_event_program_change, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_program_select(evt, channel, sfont_id, bank_num, preset_num)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] sfont_id 
  # @param [Integer] bank_num 
  # @param [Integer] preset_num 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_program_select, :fluid_event_program_select, [FluidEventT, :int, :uint, :short, :short], :void
  
  # Real-time generic instrument controllers
  # 
  # @method fluid_event_control_change(evt, channel, control, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] control 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_control_change, :fluid_event_control_change, [FluidEventT, :int, :short, :short], :void
  
  # Real-time instrument controllers shortcuts
  # 
  # @method fluid_event_pitch_bend(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_pitch_bend, :fluid_event_pitch_bend, [FluidEventT, :int, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_event_pitch_wheelsens(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_pitch_wheelsens, :fluid_event_pitch_wheelsens, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_modulation(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_modulation, :fluid_event_modulation, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_sustain(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_sustain, :fluid_event_sustain, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_pan(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_pan, :fluid_event_pan, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_volume(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_volume, :fluid_event_volume, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_reverb_send(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_reverb_send, :fluid_event_reverb_send, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_chorus_send(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_chorus_send, :fluid_event_chorus_send, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_channel_pressure(evt, channel, val)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_channel_pressure, :fluid_event_channel_pressure, [FluidEventT, :int, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_event_system_reset(evt)
  # @param [FluidEventT] evt 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_system_reset, :fluid_event_system_reset, [FluidEventT], :void
  
  # Only for removing events
  # 
  # @method fluid_event_any_control_change(evt, channel)
  # @param [FluidEventT] evt 
  # @param [Integer] channel 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_any_control_change, :fluid_event_any_control_change, [FluidEventT, :int], :void
  
  # Only when unregistering clients
  # 
  # @method fluid_event_unregistering(evt)
  # @param [FluidEventT] evt 
  # @return [nil] 
  # @scope class
  attach_function :fluid_event_unregistering, :fluid_event_unregistering, [FluidEventT], :void
  
  # Accessing event data
  # 
  # @method fluid_event_get_type(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_type, :fluid_event_get_type, [FluidEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_event_get_source(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_source, :fluid_event_get_source, [FluidEventT], :short
  
  # (Not documented)
  # 
  # @method fluid_event_get_dest(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_dest, :fluid_event_get_dest, [FluidEventT], :short
  
  # (Not documented)
  # 
  # @method fluid_event_get_channel(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_channel, :fluid_event_get_channel, [FluidEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_event_get_key(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_key, :fluid_event_get_key, [FluidEventT], :short
  
  # (Not documented)
  # 
  # @method fluid_event_get_velocity(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_velocity, :fluid_event_get_velocity, [FluidEventT], :short
  
  # (Not documented)
  # 
  # @method fluid_event_get_control(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_control, :fluid_event_get_control, [FluidEventT], :short
  
  # (Not documented)
  # 
  # @method fluid_event_get_value(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_value, :fluid_event_get_value, [FluidEventT], :short
  
  # (Not documented)
  # 
  # @method fluid_event_get_program(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_program, :fluid_event_get_program, [FluidEventT], :short
  
  # (Not documented)
  # 
  # @method fluid_event_get_data(evt)
  # @param [FluidEventT] evt 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  attach_function :fluid_event_get_data, :fluid_event_get_data, [FluidEventT], :pointer
  
  # (Not documented)
  # 
  # @method fluid_event_get_duration(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_duration, :fluid_event_get_duration, [FluidEventT], :uint
  
  # (Not documented)
  # 
  # @method fluid_event_get_bank(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_bank, :fluid_event_get_bank, [FluidEventT], :short
  
  # (Not documented)
  # 
  # @method fluid_event_get_pitch(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_pitch, :fluid_event_get_pitch, [FluidEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_event_get_sfont_id(evt)
  # @param [FluidEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_event_get_sfont_id, :fluid_event_get_sfont_id, [FluidEventT], :uint
  
  # (Not documented)
  # 
  # @method new_fluid_midi_event()
  # @return [FluidMidiEventT] 
  # @scope class
  attach_function :new_fluid_midi_event, :new_fluid_midi_event, [], FluidMidiEventT
  
  # (Not documented)
  # 
  # @method delete_fluid_midi_event(event)
  # @param [FluidMidiEventT] event 
  # @return [Integer] 
  # @scope class
  attach_function :delete_fluid_midi_event, :delete_fluid_midi_event, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_type(evt, type)
  # @param [FluidMidiEventT] evt 
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_type, :fluid_midi_event_set_type, [FluidMidiEventT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_get_type(evt)
  # @param [FluidMidiEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_get_type, :fluid_midi_event_get_type, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_channel(evt, chan)
  # @param [FluidMidiEventT] evt 
  # @param [Integer] chan 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_channel, :fluid_midi_event_set_channel, [FluidMidiEventT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_get_channel(evt)
  # @param [FluidMidiEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_get_channel, :fluid_midi_event_get_channel, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_get_key(evt)
  # @param [FluidMidiEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_get_key, :fluid_midi_event_get_key, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_key(evt, key)
  # @param [FluidMidiEventT] evt 
  # @param [Integer] key 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_key, :fluid_midi_event_set_key, [FluidMidiEventT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_get_velocity(evt)
  # @param [FluidMidiEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_get_velocity, :fluid_midi_event_get_velocity, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_velocity(evt, vel)
  # @param [FluidMidiEventT] evt 
  # @param [Integer] vel 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_velocity, :fluid_midi_event_set_velocity, [FluidMidiEventT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_get_control(evt)
  # @param [FluidMidiEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_get_control, :fluid_midi_event_get_control, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_control(evt, ctrl)
  # @param [FluidMidiEventT] evt 
  # @param [Integer] ctrl 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_control, :fluid_midi_event_set_control, [FluidMidiEventT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_get_value(evt)
  # @param [FluidMidiEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_get_value, :fluid_midi_event_get_value, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_value(evt, val)
  # @param [FluidMidiEventT] evt 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_value, :fluid_midi_event_set_value, [FluidMidiEventT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_get_program(evt)
  # @param [FluidMidiEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_get_program, :fluid_midi_event_get_program, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_program(evt, val)
  # @param [FluidMidiEventT] evt 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_program, :fluid_midi_event_set_program, [FluidMidiEventT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_get_pitch(evt)
  # @param [FluidMidiEventT] evt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_get_pitch, :fluid_midi_event_get_pitch, [FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_pitch(evt, val)
  # @param [FluidMidiEventT] evt 
  # @param [Integer] val 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_pitch, :fluid_midi_event_set_pitch, [FluidMidiEventT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_event_set_sysex(evt, data, size, dynamic)
  # @param [FluidMidiEventT] evt 
  # @param [FFI::Pointer(*Void)] data 
  # @param [Integer] size 
  # @param [Integer] dynamic 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_event_set_sysex, :fluid_midi_event_set_sysex, [FluidMidiEventT, :pointer, :int, :int], :int
  
  # MIDI router rule type.
  # @since 1.1.0
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_midi_router_rule_type).</em>
  # 
  # === Options:
  # :note ::
  #   
  # :cc ::
  #   < MIDI note rule
  # :prog_change ::
  #   < MIDI controller rule
  # :pitch_bend ::
  #   < MIDI program change rule
  # :channel_pressure ::
  #   < MIDI pitch bend rule
  # :key_pressure ::
  #   < MIDI channel pressure rule
  # :count ::
  #   < MIDI key pressure rule
  # 
  # @method _enum_fluid_midi_router_rule_type_
  # @return [Symbol]
  # @scope class
  enum :fluid_midi_router_rule_type, [
    :note,
    :cc,
    :prog_change,
    :pitch_bend,
    :channel_pressure,
    :key_pressure,
    :count
  ]
  
  # Generic callback function for MIDI events.
  # @param data User defined data pointer
  # @param event The MIDI event
  # @return Should return #FLUID_OK on success, #FLUID_FAILED otherwise
  # 
  # Will be used between
  # - MIDI driver and MIDI router
  # - MIDI router and synth
  # to communicate events.
  # In the not-so-far future...
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_handle_midi_event_func_t_(event)
  # @param [FluidMidiEventT] event 
  # @return [FFI::Pointer(*Void)] 
  # @scope class
  callback :handle_midi_event_func_t, [FluidMidiEventT], :pointer
  
  # (Not documented)
  # 
  # @method new_fluid_midi_router(settings, handler, event_handler_data)
  # @param [FluidHashtableT] settings 
  # @param [Proc(_callback_handle_midi_event_func_t_)] handler 
  # @param [FFI::Pointer(*Void)] event_handler_data 
  # @return [FluidMidiRouterT] 
  # @scope class
  attach_function :new_fluid_midi_router, :new_fluid_midi_router, [FluidHashtableT, :handle_midi_event_func_t, :pointer], FluidMidiRouterT
  
  # (Not documented)
  # 
  # @method delete_fluid_midi_router(handler)
  # @param [FluidMidiRouterT] handler 
  # @return [Integer] 
  # @scope class
  attach_function :delete_fluid_midi_router, :delete_fluid_midi_router, [FluidMidiRouterT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_router_set_default_rules(router)
  # @param [FluidMidiRouterT] router 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_router_set_default_rules, :fluid_midi_router_set_default_rules, [FluidMidiRouterT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_router_clear_rules(router)
  # @param [FluidMidiRouterT] router 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_router_clear_rules, :fluid_midi_router_clear_rules, [FluidMidiRouterT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_router_add_rule(router, rule, type)
  # @param [FluidMidiRouterT] router 
  # @param [FluidMidiRouterRuleT] rule 
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_router_add_rule, :fluid_midi_router_add_rule, [FluidMidiRouterT, FluidMidiRouterRuleT, :int], :int
  
  # (Not documented)
  # 
  # @method new_fluid_midi_router_rule()
  # @return [FluidMidiRouterRuleT] 
  # @scope class
  attach_function :new_fluid_midi_router_rule, :new_fluid_midi_router_rule, [], FluidMidiRouterRuleT
  
  # (Not documented)
  # 
  # @method delete_fluid_midi_router_rule(rule)
  # @param [FluidMidiRouterRuleT] rule 
  # @return [nil] 
  # @scope class
  attach_function :delete_fluid_midi_router_rule, :delete_fluid_midi_router_rule, [FluidMidiRouterRuleT], :void
  
  # (Not documented)
  # 
  # @method fluid_midi_router_rule_set_chan(rule, min, max, mul, add)
  # @param [FluidMidiRouterRuleT] rule 
  # @param [Integer] min 
  # @param [Integer] max 
  # @param [Float] mul 
  # @param [Integer] add 
  # @return [nil] 
  # @scope class
  attach_function :fluid_midi_router_rule_set_chan, :fluid_midi_router_rule_set_chan, [FluidMidiRouterRuleT, :int, :int, :float, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_midi_router_rule_set_param1(rule, min, max, mul, add)
  # @param [FluidMidiRouterRuleT] rule 
  # @param [Integer] min 
  # @param [Integer] max 
  # @param [Float] mul 
  # @param [Integer] add 
  # @return [nil] 
  # @scope class
  attach_function :fluid_midi_router_rule_set_param1, :fluid_midi_router_rule_set_param1, [FluidMidiRouterRuleT, :int, :int, :float, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_midi_router_rule_set_param2(rule, min, max, mul, add)
  # @param [FluidMidiRouterRuleT] rule 
  # @param [Integer] min 
  # @param [Integer] max 
  # @param [Float] mul 
  # @param [Integer] add 
  # @return [nil] 
  # @scope class
  attach_function :fluid_midi_router_rule_set_param2, :fluid_midi_router_rule_set_param2, [FluidMidiRouterRuleT, :int, :int, :float, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_midi_router_handle_midi_event(data, event)
  # @param [FFI::Pointer(*Void)] data 
  # @param [FluidMidiEventT] event 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_router_handle_midi_event, :fluid_midi_router_handle_midi_event, [:pointer, FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_dump_prerouter(data, event)
  # @param [FFI::Pointer(*Void)] data 
  # @param [FluidMidiEventT] event 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_dump_prerouter, :fluid_midi_dump_prerouter, [:pointer, FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method fluid_midi_dump_postrouter(data, event)
  # @param [FFI::Pointer(*Void)] data 
  # @param [FluidMidiEventT] event 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_midi_dump_postrouter, :fluid_midi_dump_postrouter, [:pointer, FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # @method new_fluid_midi_driver(settings, handler, event_handler_data)
  # @param [FluidHashtableT] settings 
  # @param [Proc(_callback_handle_midi_event_func_t_)] handler 
  # @param [FFI::Pointer(*Void)] event_handler_data 
  # @return [FluidMidiDriverT] 
  # @scope class
  attach_function :new_fluid_midi_driver, :new_fluid_midi_driver, [FluidHashtableT, :handle_midi_event_func_t, :pointer], FluidMidiDriverT
  
  # (Not documented)
  # 
  # @method delete_fluid_midi_driver(driver)
  # @param [FluidMidiDriverT] driver 
  # @return [nil] 
  # @scope class
  attach_function :delete_fluid_midi_driver, :delete_fluid_midi_driver, [FluidMidiDriverT], :void
  
  # MIDI player status enum.
  # @since 1.1.0
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_player_status).</em>
  # 
  # === Options:
  # :ready ::
  #   
  # :playing ::
  #   < Player is ready
  # :done ::
  #   < Player is currently playing
  # 
  # @method _enum_fluid_player_status_
  # @return [Symbol]
  # @scope class
  enum :fluid_player_status, [
    :ready,
    :playing,
    :done
  ]
  
  # < Player is finished playing
  # 
  # @method new_fluid_player(synth)
  # @param [FluidSynthT] synth 
  # @return [FluidPlayerT] 
  # @scope class
  attach_function :new_fluid_player, :new_fluid_player, [FluidSynthT], FluidPlayerT
  
  # (Not documented)
  # 
  # @method delete_fluid_player(player)
  # @param [FluidPlayerT] player 
  # @return [Integer] 
  # @scope class
  attach_function :delete_fluid_player, :delete_fluid_player, [FluidPlayerT], :int
  
  # (Not documented)
  # 
  # @method fluid_player_add(player, midifile)
  # @param [FluidPlayerT] player 
  # @param [String] midifile 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_add, :fluid_player_add, [FluidPlayerT, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_player_add_mem(player, buffer, len)
  # @param [FluidPlayerT] player 
  # @param [FFI::Pointer(*Void)] buffer 
  # @param [Integer] len 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_add_mem, :fluid_player_add_mem, [FluidPlayerT, :pointer, :ulong], :int
  
  # (Not documented)
  # 
  # @method fluid_player_play(player)
  # @param [FluidPlayerT] player 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_play, :fluid_player_play, [FluidPlayerT], :int
  
  # (Not documented)
  # 
  # @method fluid_player_stop(player)
  # @param [FluidPlayerT] player 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_stop, :fluid_player_stop, [FluidPlayerT], :int
  
  # (Not documented)
  # 
  # @method fluid_player_join(player)
  # @param [FluidPlayerT] player 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_join, :fluid_player_join, [FluidPlayerT], :int
  
  # (Not documented)
  # 
  # @method fluid_player_set_loop(player, loop)
  # @param [FluidPlayerT] player 
  # @param [Integer] loop 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_set_loop, :fluid_player_set_loop, [FluidPlayerT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_player_set_midi_tempo(player, tempo)
  # @param [FluidPlayerT] player 
  # @param [Integer] tempo 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_set_midi_tempo, :fluid_player_set_midi_tempo, [FluidPlayerT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_player_set_bpm(player, bpm)
  # @param [FluidPlayerT] player 
  # @param [Integer] bpm 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_set_bpm, :fluid_player_set_bpm, [FluidPlayerT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_player_get_status(player)
  # @param [FluidPlayerT] player 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_get_status, :fluid_player_get_status, [FluidPlayerT], :int
  
  # (Not documented)
  # 
  # @method fluid_player_set_playback_callback(player, handler, handler_data)
  # @param [FluidPlayerT] player 
  # @param [Proc(_callback_handle_midi_event_func_t_)] handler 
  # @param [FFI::Pointer(*Void)] handler_data 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_player_set_playback_callback, :fluid_player_set_playback_callback, [FluidPlayerT, :handle_midi_event_func_t, :pointer], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_fluid_event_callback_t_(event, seq, data)
  # @param [FluidEventT] event 
  # @param [FluidSequencerT] seq 
  # @param [FFI::Pointer(*Void)] data 
  # @return [Integer] 
  # @scope class
  callback :fluid_event_callback_t, [FluidEventT, FluidSequencerT, :pointer], :uint
  
  # (Not documented)
  # 
  # @method new_fluid_sequencer()
  # @return [FluidSequencerT] 
  # @scope class
  attach_function :new_fluid_sequencer, :new_fluid_sequencer, [], FluidSequencerT
  
  # (Not documented)
  # 
  # @method new_fluid_sequencer2(use_system_timer)
  # @param [Integer] use_system_timer 
  # @return [FluidSequencerT] 
  # @scope class
  attach_function :new_fluid_sequencer2, :new_fluid_sequencer2, [:int], FluidSequencerT
  
  # (Not documented)
  # 
  # @method delete_fluid_sequencer(seq)
  # @param [FluidSequencerT] seq 
  # @return [nil] 
  # @scope class
  attach_function :delete_fluid_sequencer, :delete_fluid_sequencer, [FluidSequencerT], :void
  
  # (Not documented)
  # 
  # @method fluid_sequencer_get_use_system_timer(seq)
  # @param [FluidSequencerT] seq 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_get_use_system_timer, :fluid_sequencer_get_use_system_timer, [FluidSequencerT], :int
  
  # (Not documented)
  # 
  # @method fluid_sequencer_register_client(seq, name, callback, data)
  # @param [FluidSequencerT] seq 
  # @param [String] name 
  # @param [Proc(_callback_fluid_event_callback_t_)] callback 
  # @param [FFI::Pointer(*Void)] data 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_register_client, :fluid_sequencer_register_client, [FluidSequencerT, :string, :fluid_event_callback_t, :pointer], :short
  
  # (Not documented)
  # 
  # @method fluid_sequencer_unregister_client(seq, id)
  # @param [FluidSequencerT] seq 
  # @param [Integer] id 
  # @return [nil] 
  # @scope class
  attach_function :fluid_sequencer_unregister_client, :fluid_sequencer_unregister_client, [FluidSequencerT, :short], :void
  
  # (Not documented)
  # 
  # @method fluid_sequencer_count_clients(seq)
  # @param [FluidSequencerT] seq 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_count_clients, :fluid_sequencer_count_clients, [FluidSequencerT], :int
  
  # (Not documented)
  # 
  # @method fluid_sequencer_get_client_id(seq, index)
  # @param [FluidSequencerT] seq 
  # @param [Integer] index 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_get_client_id, :fluid_sequencer_get_client_id, [FluidSequencerT, :int], :short
  
  # (Not documented)
  # 
  # @method fluid_sequencer_get_client_name(seq, id)
  # @param [FluidSequencerT] seq 
  # @param [Integer] id 
  # @return [String] 
  # @scope class
  attach_function :fluid_sequencer_get_client_name, :fluid_sequencer_get_client_name, [FluidSequencerT, :int], :string
  
  # (Not documented)
  # 
  # @method fluid_sequencer_client_is_dest(seq, id)
  # @param [FluidSequencerT] seq 
  # @param [Integer] id 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_client_is_dest, :fluid_sequencer_client_is_dest, [FluidSequencerT, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_sequencer_process(seq, msec)
  # @param [FluidSequencerT] seq 
  # @param [Integer] msec 
  # @return [nil] 
  # @scope class
  attach_function :fluid_sequencer_process, :fluid_sequencer_process, [FluidSequencerT, :uint], :void
  
  # (Not documented)
  # 
  # @method fluid_sequencer_send_now(seq, evt)
  # @param [FluidSequencerT] seq 
  # @param [FluidEventT] evt 
  # @return [nil] 
  # @scope class
  attach_function :fluid_sequencer_send_now, :fluid_sequencer_send_now, [FluidSequencerT, FluidEventT], :void
  
  # (Not documented)
  # 
  # @method fluid_sequencer_send_at(seq, evt, time, absolute)
  # @param [FluidSequencerT] seq 
  # @param [FluidEventT] evt 
  # @param [Integer] time 
  # @param [Integer] absolute 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_send_at, :fluid_sequencer_send_at, [FluidSequencerT, FluidEventT, :uint, :int], :int
  
  # (Not documented)
  # 
  # @method fluid_sequencer_remove_events(seq, source, dest, type)
  # @param [FluidSequencerT] seq 
  # @param [Integer] source 
  # @param [Integer] dest 
  # @param [Integer] type 
  # @return [nil] 
  # @scope class
  attach_function :fluid_sequencer_remove_events, :fluid_sequencer_remove_events, [FluidSequencerT, :short, :short, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_sequencer_get_tick(seq)
  # @param [FluidSequencerT] seq 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_get_tick, :fluid_sequencer_get_tick, [FluidSequencerT], :uint
  
  # (Not documented)
  # 
  # @method fluid_sequencer_set_time_scale(seq, scale)
  # @param [FluidSequencerT] seq 
  # @param [Float] scale 
  # @return [nil] 
  # @scope class
  attach_function :fluid_sequencer_set_time_scale, :fluid_sequencer_set_time_scale, [FluidSequencerT, :double], :void
  
  # (Not documented)
  # 
  # @method fluid_sequencer_get_time_scale(seq)
  # @param [FluidSequencerT] seq 
  # @return [Float] 
  # @scope class
  attach_function :fluid_sequencer_get_time_scale, :fluid_sequencer_get_time_scale, [FluidSequencerT], :double
  
  # (Not documented)
  # 
  # @method fluid_sequencer_register_fluidsynth(seq, synth)
  # @param [FluidSequencerT] seq 
  # @param [FluidSynthT] synth 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_register_fluidsynth, :fluid_sequencer_register_fluidsynth, [FluidSequencerT, FluidSynthT], :short
  
  # (Not documented)
  # 
  # @method fluid_sequencer_add_midi_event_to_buffer(data, event)
  # @param [FFI::Pointer(*Void)] data 
  # @param [FluidMidiEventT] event 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_sequencer_add_midi_event_to_buffer, :fluid_sequencer_add_midi_event_to_buffer, [:pointer, FluidMidiEventT], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_log_level).</em>
  # 
  # === Options:
  # :fluid_panic ::
  #   
  # :fluid_err ::
  #   < The synth can't function correctly any more
  # :fluid_warn ::
  #   < Serious error occurred
  # :fluid_info ::
  #   < Warning
  # :fluid_dbg ::
  #   < Verbose informational messages
  # :last_log_level ::
  #   < Debugging messages
  # 
  # @method _enum_fluid_log_level_
  # @return [Symbol]
  # @scope class
  enum :fluid_log_level, [
    :fluid_panic,
    :fluid_err,
    :fluid_warn,
    :fluid_info,
    :fluid_dbg,
    :last_log_level
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_fluid_log_function_t_(message, data)
  # @param [String] message 
  # @param [FFI::Pointer(*Void)] data 
  # @return [Integer] 
  # @scope class
  callback :fluid_log_function_t, [:string, :pointer], :int
  
  # (Not documented)
  # 
  # @method fluid_set_log_function(level, fun, data)
  # @param [Integer] level 
  # @param [Proc(_callback_fluid_log_function_t_)] fun 
  # @param [FFI::Pointer(*Void)] data 
  # @return [Proc(_callback_fluid_log_function_t_)] 
  # @scope class
  attach_function :fluid_set_log_function, :fluid_set_log_function, [:int, :fluid_log_function_t, :pointer], :fluid_log_function_t
  
  # (Not documented)
  # 
  # @method fluid_default_log_function(level, message, data)
  # @param [Integer] level 
  # @param [String] message 
  # @param [FFI::Pointer(*Void)] data 
  # @return [nil] 
  # @scope class
  attach_function :fluid_default_log_function, :fluid_default_log_function, [:int, :string, :pointer], :void
  
  # (Not documented)
  # 
  # @method fluid_log(level, fmt)
  # @param [Integer] level 
  # @param [String] fmt 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_log, :fluid_log, [:int, :string], :int
  
  # (Not documented)
  # 
  # @method fluid_is_soundfont(filename)
  # @param [String] filename 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_is_soundfont, :fluid_is_soundfont, [:string], :int
  
  # (Not documented)
  # 
  # @method fluid_is_midifile(filename)
  # @param [String] filename 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_is_midifile, :fluid_is_midifile, [:string], :int
  
  # < SoundFont sample
  # 
  # = Fields:
  # :dest ::
  #   (Integer) < Destination generator to control
  # :src1 ::
  #   (Integer) < Source controller 1
  # :flags1 ::
  #   (Integer) < Source controller 1 flags
  # :src2 ::
  #   (Integer) < Source controller 2
  # :flags2 ::
  #   (Integer) < Source controller 2 flags
  # :amount ::
  #   (Float) < Multiplier amount
  # :next ::
  #   (FFI::Pointer(*FluidModT)) The 'next' field allows to link modulators into a list.  It is
  #   not used in fluid_voice.c, there each voice allocates memory for a
  #   fixed number of modulators.  Since there may be a huge number of
  #   different zones, this is more efficient.
  class FluidModT < FFI::Struct
    layout :dest, :uchar,
           :src1, :uchar,
           :flags1, :uchar,
           :src2, :uchar,
           :flags2, :uchar,
           :amount, :double,
           :next, :pointer
  end
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_mod_flags).</em>
  # 
  # === Options:
  # :positive ::
  #   
  # :negative ::
  #   < Mapping function is positive
  # :unipolar ::
  #   < Mapping function is negative
  # :bipolar ::
  #   < Mapping function is unipolar
  # :linear ::
  #   < Mapping function is bipolar
  # :concave ::
  #   < Linear mapping function
  # :convex ::
  #   < Concave mapping function
  # :switch ::
  #   < Convex mapping function
  # :gc ::
  #   < Switch (on/off) mapping function
  # :cc ::
  #   < General controller source type (#fluid_mod_src)
  # 
  # @method _enum_fluid_mod_flags_
  # @return [Symbol]
  # @scope class
  enum :fluid_mod_flags, [
    :positive, 0,
    :negative, 1,
    :unipolar, 0,
    :bipolar, 2,
    :linear, 0,
    :concave, 4,
    :convex, 8,
    :switch, 12,
    :gc, 0,
    :cc, 16
  ]
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_mod_src).</em>
  # 
  # === Options:
  # :none ::
  #   
  # :velocity ::
  #   < No source controller
  # :key ::
  #   < MIDI note-on velocity
  # :keypressure ::
  #   < MIDI note-on note number
  # :channelpressure ::
  #   < MIDI key pressure
  # :pitchwheel ::
  #   < MIDI channel pressure
  # :pitchwheelsens ::
  #   < Pitch wheel
  # 
  # @method _enum_fluid_mod_src_
  # @return [Symbol]
  # @scope class
  enum :fluid_mod_src, [
    :none, 0,
    :velocity, 2,
    :key, 3,
    :keypressure, 10,
    :channelpressure, 13,
    :pitchwheel, 14,
    :pitchwheelsens, 16
  ]
  
  # (Not documented)
  # 
  # @method fluid_mod_new()
  # @return [FluidModT] 
  # @scope class
  attach_function :fluid_mod_new, :fluid_mod_new, [], FluidModT
  
  # (Not documented)
  # 
  # @method fluid_mod_delete(mod)
  # @param [FluidModT] mod 
  # @return [nil] 
  # @scope class
  attach_function :fluid_mod_delete, :fluid_mod_delete, [FluidModT], :void
  
  # (Not documented)
  # 
  # @method fluid_mod_set_source1(mod, src, flags)
  # @param [FluidModT] mod 
  # @param [Integer] src 
  # @param [Integer] flags 
  # @return [nil] 
  # @scope class
  attach_function :fluid_mod_set_source1, :fluid_mod_set_source1, [FluidModT, :int, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_mod_set_source2(mod, src, flags)
  # @param [FluidModT] mod 
  # @param [Integer] src 
  # @param [Integer] flags 
  # @return [nil] 
  # @scope class
  attach_function :fluid_mod_set_source2, :fluid_mod_set_source2, [FluidModT, :int, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_mod_set_dest(mod, dst)
  # @param [FluidModT] mod 
  # @param [Integer] dst 
  # @return [nil] 
  # @scope class
  attach_function :fluid_mod_set_dest, :fluid_mod_set_dest, [FluidModT, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_mod_set_amount(mod, amount)
  # @param [FluidModT] mod 
  # @param [Float] amount 
  # @return [nil] 
  # @scope class
  attach_function :fluid_mod_set_amount, :fluid_mod_set_amount, [FluidModT, :double], :void
  
  # (Not documented)
  # 
  # @method fluid_mod_get_source1(mod)
  # @param [FluidModT] mod 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_mod_get_source1, :fluid_mod_get_source1, [FluidModT], :int
  
  # (Not documented)
  # 
  # @method fluid_mod_get_flags1(mod)
  # @param [FluidModT] mod 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_mod_get_flags1, :fluid_mod_get_flags1, [FluidModT], :int
  
  # (Not documented)
  # 
  # @method fluid_mod_get_source2(mod)
  # @param [FluidModT] mod 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_mod_get_source2, :fluid_mod_get_source2, [FluidModT], :int
  
  # (Not documented)
  # 
  # @method fluid_mod_get_flags2(mod)
  # @param [FluidModT] mod 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_mod_get_flags2, :fluid_mod_get_flags2, [FluidModT], :int
  
  # (Not documented)
  # 
  # @method fluid_mod_get_dest(mod)
  # @param [FluidModT] mod 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_mod_get_dest, :fluid_mod_get_dest, [FluidModT], :int
  
  # (Not documented)
  # 
  # @method fluid_mod_get_amount(mod)
  # @param [FluidModT] mod 
  # @return [Float] 
  # @scope class
  attach_function :fluid_mod_get_amount, :fluid_mod_get_amount, [FluidModT], :double
  
  # (Not documented)
  # 
  # @method fluid_mod_test_identity(mod1, mod2)
  # @param [FluidModT] mod1 
  # @param [FluidModT] mod2 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_mod_test_identity, :fluid_mod_test_identity, [FluidModT, FluidModT], :int
  
  # (Not documented)
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_gen_type).</em>
  # 
  # === Options:
  # :startaddrofs ::
  #   
  # :endaddrofs ::
  #   < Sample start address offset (0-32767)
  # :startloopaddrofs ::
  #   < Sample end address offset (-32767-0)
  # :endloopaddrofs ::
  #   < Sample loop start address offset (-32767-32767)
  # :startaddrcoarseofs ::
  #   < Sample loop end address offset (-32767-32767)
  # :modlfotopitch ::
  #   < Sample start address coarse offset (X 32768)
  # :viblfotopitch ::
  #   < Modulation LFO to pitch
  # :modenvtopitch ::
  #   < Vibrato LFO to pitch
  # :filterfc ::
  #   < Modulation envelope to pitch
  # :filterq ::
  #   < Filter cutoff
  # :modlfotofilterfc ::
  #   < Filter Q
  # :modenvtofilterfc ::
  #   < Modulation LFO to filter cutoff
  # :endaddrcoarseofs ::
  #   < Modulation envelope to filter cutoff
  # :modlfotovol ::
  #   < Sample end address coarse offset (X 32768)
  # :unused1 ::
  #   < Modulation LFO to volume
  # :chorussend ::
  #   < Unused
  # :reverbsend ::
  #   < Chorus send amount
  # :pan ::
  #   < Reverb send amount
  # :unused2 ::
  #   < Stereo panning
  # :unused3 ::
  #   < Unused
  # :unused4 ::
  #   < Unused
  # :modlfodelay ::
  #   < Unused
  # :modlfofreq ::
  #   < Modulation LFO delay
  # :viblfodelay ::
  #   < Modulation LFO frequency
  # :viblfofreq ::
  #   < Vibrato LFO delay
  # :modenvdelay ::
  #   < Vibrato LFO frequency
  # :modenvattack ::
  #   < Modulation envelope delay
  # :modenvhold ::
  #   < Modulation envelope attack
  # :modenvdecay ::
  #   < Modulation envelope hold
  # :modenvsustain ::
  #   < Modulation envelope decay
  # :modenvrelease ::
  #   < Modulation envelope sustain
  # :keytomodenvhold ::
  #   < Modulation envelope release
  # :keytomodenvdecay ::
  #   < Key to modulation envelope hold
  # :volenvdelay ::
  #   < Key to modulation envelope decay
  # :volenvattack ::
  #   < Volume envelope delay
  # :volenvhold ::
  #   < Volume envelope attack
  # :volenvdecay ::
  #   < Volume envelope hold
  # :volenvsustain ::
  #   < Volume envelope decay
  # :volenvrelease ::
  #   < Volume envelope sustain
  # :keytovolenvhold ::
  #   < Volume envelope release
  # :keytovolenvdecay ::
  #   < Key to volume envelope hold
  # :instrument ::
  #   < Key to volume envelope decay
  # :reserved1 ::
  #   < Instrument ID (shouldn't be set by user)
  # :keyrange ::
  #   < Reserved
  # :velrange ::
  #   < MIDI note range
  # :startloopaddrcoarseofs ::
  #   < MIDI velocity range
  # :keynum ::
  #   < Sample start loop address coarse offset (X 32768)
  # :velocity ::
  #   < Fixed MIDI note number
  # :attenuation ::
  #   < Fixed MIDI velocity value
  # :reserved2 ::
  #   < Initial volume attenuation
  # :endloopaddrcoarseofs ::
  #   < Reserved
  # :coarsetune ::
  #   < Sample end loop address coarse offset (X 32768)
  # :finetune ::
  #   < Coarse tuning
  # :sampleid ::
  #   < Fine tuning
  # :samplemode ::
  #   < Sample ID (shouldn't be set by user)
  # :reserved3 ::
  #   < Sample mode flags
  # :scaletune ::
  #   < Reserved
  # :exclusiveclass ::
  #   < Scale tuning
  # :overriderootkey ::
  #   < Exclusive class number
  # :pitch ::
  #   the initial pitch is not a "standard" generator. It is not
  #   mentioned in the list of generator in the SF2 specifications. It
  #   is used, however, as the destination for the default pitch wheel
  #   modulator.
  # :last ::
  #   < Pitch (NOTE: Not a real SoundFont generator)
  # 
  # @method _enum_fluid_gen_type_
  # @return [Symbol]
  # @scope class
  enum :fluid_gen_type, [
    :startaddrofs,
    :endaddrofs,
    :startloopaddrofs,
    :endloopaddrofs,
    :startaddrcoarseofs,
    :modlfotopitch,
    :viblfotopitch,
    :modenvtopitch,
    :filterfc,
    :filterq,
    :modlfotofilterfc,
    :modenvtofilterfc,
    :endaddrcoarseofs,
    :modlfotovol,
    :unused1,
    :chorussend,
    :reverbsend,
    :pan,
    :unused2,
    :unused3,
    :unused4,
    :modlfodelay,
    :modlfofreq,
    :viblfodelay,
    :viblfofreq,
    :modenvdelay,
    :modenvattack,
    :modenvhold,
    :modenvdecay,
    :modenvsustain,
    :modenvrelease,
    :keytomodenvhold,
    :keytomodenvdecay,
    :volenvdelay,
    :volenvattack,
    :volenvhold,
    :volenvdecay,
    :volenvsustain,
    :volenvrelease,
    :keytovolenvhold,
    :keytovolenvdecay,
    :instrument,
    :reserved1,
    :keyrange,
    :velrange,
    :startloopaddrcoarseofs,
    :keynum,
    :velocity,
    :attenuation,
    :reserved2,
    :endloopaddrcoarseofs,
    :coarsetune,
    :finetune,
    :sampleid,
    :samplemode,
    :reserved3,
    :scaletune,
    :exclusiveclass,
    :overriderootkey,
    :pitch,
    :last
  ]
  
  # (Not documented)
  # 
  # = Fields:
  # :flags ::
  #   (Integer) < Is the generator set or not (#fluid_gen_flags)
  # :val ::
  #   (Float) < The nominal value
  # :mod ::
  #   (Float) < Change by modulators
  # :nrpn ::
  #   (Float) < Change by NRPN messages
  class FluidGenT < FFI::Struct
    layout :flags, :uchar,
           :val, :double,
           :mod, :double,
           :nrpn, :double
  end
  
  # (Not documented)
  # 
  # = Fields:
  # :flags ::
  #   (Integer) < Is the generator set or not (#fluid_gen_flags)
  # :val ::
  #   (Float) < The nominal value
  # :mod ::
  #   (Float) < Change by modulators
  # :nrpn ::
  #   (Float) < Change by NRPN messages
  class FluidGenT < FFI::Struct
    layout :flags, :uchar,
           :val, :double,
           :mod, :double,
           :nrpn, :double
  end
  
  # Enum value for 'flags' field of #fluid_gen_t (not really flags).
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:fluid_gen_flags).</em>
  # 
  # === Options:
  # :unused ::
  #   
  # :set ::
  #   < Generator value is not set
  # :abs_nrpn ::
  #   < Generator value is set
  # 
  # @method _enum_fluid_gen_flags_
  # @return [Symbol]
  # @scope class
  enum :fluid_gen_flags, [
    :unused,
    :set,
    :abs_nrpn
  ]
  
  # < Generator is an absolute value
  # 
  # @method fluid_gen_set_default_values(gen)
  # @param [FluidGenT] gen 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_gen_set_default_values, :fluid_gen_set_default_values, [FluidGenT], :int
  
  # (Not documented)
  # 
  # @method fluid_voice_update_param(voice, gen)
  # @param [FluidVoiceT] voice 
  # @param [Integer] gen 
  # @return [nil] 
  # @scope class
  attach_function :fluid_voice_update_param, :fluid_voice_update_param, [FluidVoiceT, :int], :void
  
  # < For default modulators only, no need to check for duplicates
  # 
  # @method fluid_voice_add_mod(voice, mod, mode)
  # @param [FluidVoiceT] voice 
  # @param [FluidModT] mod 
  # @param [Integer] mode 
  # @return [nil] 
  # @scope class
  attach_function :fluid_voice_add_mod, :fluid_voice_add_mod, [FluidVoiceT, FluidModT, :int], :void
  
  # (Not documented)
  # 
  # @method fluid_voice_gen_set(voice, gen, val)
  # @param [FluidVoiceT] voice 
  # @param [Integer] gen 
  # @param [Float] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_voice_gen_set, :fluid_voice_gen_set, [FluidVoiceT, :int, :float], :void
  
  # (Not documented)
  # 
  # @method fluid_voice_gen_get(voice, gen)
  # @param [FluidVoiceT] voice 
  # @param [Integer] gen 
  # @return [Float] 
  # @scope class
  attach_function :fluid_voice_gen_get, :fluid_voice_gen_get, [FluidVoiceT, :int], :float
  
  # (Not documented)
  # 
  # @method fluid_voice_gen_incr(voice, gen, val)
  # @param [FluidVoiceT] voice 
  # @param [Integer] gen 
  # @param [Float] val 
  # @return [nil] 
  # @scope class
  attach_function :fluid_voice_gen_incr, :fluid_voice_gen_incr, [FluidVoiceT, :int, :float], :void
  
  # (Not documented)
  # 
  # @method fluid_voice_get_id(voice)
  # @param [FluidVoiceT] voice 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_voice_get_id, :fluid_voice_get_id, [FluidVoiceT], :uint
  
  # (Not documented)
  # 
  # @method fluid_voice_is_playing(voice)
  # @param [FluidVoiceT] voice 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_voice_is_playing, :fluid_voice_is_playing, [FluidVoiceT], :int
  
  # (Not documented)
  # 
  # @method fluid_voice_optimize_sample(s)
  # @param [FluidSampleT] s 
  # @return [Integer] 
  # @scope class
  attach_function :fluid_voice_optimize_sample, :fluid_voice_optimize_sample, [FluidSampleT], :int
  
  # (Not documented)
  # 
  # @method fluid_version(major, minor, micro)
  # @param [FFI::Pointer(*Int)] major 
  # @param [FFI::Pointer(*Int)] minor 
  # @param [FFI::Pointer(*Int)] micro 
  # @return [nil] 
  # @scope class
  attach_function :fluid_version, :fluid_version, [:pointer, :pointer, :pointer], :void
  
  # (Not documented)
  # 
  # @method fluid_version_str()
  # @return [String] 
  # @scope class
  attach_function :fluid_version_str, :fluid_version_str, [], :string
  
end
